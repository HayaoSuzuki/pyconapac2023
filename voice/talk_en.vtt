WEBVTT

00:00:00.109 --> 00:00:05.412
Hello everyone Today I will be talking about Let's implement

00:00:05.426 --> 00:00:11.235
useless Python objects The presentation materials for this talk are

00:00:11.250 --> 00:00:17.176
available on my GitHub repository Also the Twitter no sorry

00:00:17.426 --> 00:00:21.338
the X hashtag for this room is here Let me

00:00:21.353 --> 00:00:27.294
introduce myself My name is Hayao Suzuki It is written

00:00:27.309 --> 00:00:32.559
my name in Kanji or chinese character My Twitter No

00:00:32.779 --> 00:00:37.176
X accounts are here I work at Be-Proud a Gold

00:00:37.191 --> 00:00:44.559
Sponsor of PyCon APAC 2023 Let me introduce Be-Proud There

00:00:44.574 --> 00:00:51.823
are our services connpass the networking event site Pie-Q the

00:00:51.838 --> 00:00:57.294
best way to learn Python online tracery a system development

00:00:57.309 --> 00:01:04.044
documentation service Now we are currently hiring Let's work with

00:01:04.059 --> 00:01:10.029
us Recently I published a translated book from O'Reilly Japan

00:01:11.044 --> 00:01:16.000
This book Do you have it Please buy it on

00:01:16.015 --> 00:01:21.088
Amazon or bookstores This is my fourth time speaking at

00:01:21.103 --> 00:01:25.853
PyCon JP For the most part I speak on topics

00:01:25.868 --> 00:01:31.103
I like And now today's topic is Let's implement useless

00:01:31.118 --> 00:01:39.603
Python objects Let's implement useless Python objects So yes useless

00:01:40.618 --> 00:01:45.926
First let's review the definition of the word useless What

00:01:45.941 --> 00:01:51.676
does useless mean Let us quote from the dictionary not

00:01:51.691 --> 00:01:56.618
useful or effective in any way unable or unwilling to

00:01:56.632 --> 00:02:01.088
do anything properly I see that useless is the negative

00:02:01.103 --> 00:02:04.853
word for useful But I would like to ask all

00:02:04.868 --> 00:02:10.426
of you here Is useless really useless Let me quote

00:02:10.441 --> 00:02:15.882
from the ancient Chinese philosopher Zhuangzi's Renjian shi The English

00:02:15.897 --> 00:02:20.559
word for Renjian shi is human world This is ancient

00:02:20.574 --> 00:02:25.544
Chinese The ancient Japanese people developed a way to read

00:02:25.559 --> 00:02:32.382
this as Japanese Translated into English it reads Everyone knows

00:02:32.397 --> 00:02:35.544
the usefulness of the useful but no one knows the

00:02:35.559 --> 00:02:41.750
uselessness of the useless What does this mean Useless objects

00:02:41.809 --> 00:02:45.221
are not useful but the way we make useless objects

00:02:45.294 --> 00:02:52.044
is useful As Zhuangzi says useless objects are useful By

00:02:52.059 --> 00:02:57.206
the way what exactly are useless Python objects Here's an

00:02:57.221 --> 00:03:02.632
example A LiarContainer object says it doesn't have an object

00:03:02.647 --> 00:03:06.059
it actually has and claims to have an object it

00:03:06.074 --> 00:03:12.073
doesn't have It is useful I think The next example

00:03:12.132 --> 00:03:18.353
is a FibonacciSized object The len function returns the Fibonacci

00:03:18.368 --> 00:03:22.471
sequence of the number of elements in the object It

00:03:22.485 --> 00:03:28.162
is useful I think The another next is ShuffledIterable object

00:03:29.176 --> 00:03:32.779
When iterated with a for statement it returns a random

00:03:32.794 --> 00:03:38.721
result each time It is useful I think And now

00:03:38.838 --> 00:03:43.456
there are four basic data structures in Python lists tuples

00:03:43.647 --> 00:03:48.412
dictionaries and sets Each of these is a different data

00:03:48.426 --> 00:03:53.426
structure but they also have some common elements In each

00:03:53.441 --> 00:03:56.588
case the number of elements can be obtained with the

00:03:56.603 --> 00:04:01.191
len function The in operator can be used to check

00:04:01.206 --> 00:04:06.073
whether an element exists or not And you can iterate

00:04:06.088 --> 00:04:11.882
with the for operator len in for How do we

00:04:11.897 --> 00:04:15.912
create our own objects that are compatible with these operations

00:04:16.926 --> 00:04:20.853
Let's start with the in operator To make your own

00:04:20.868 --> 00:04:25.721
class correspond to the in operator implement the contains method

00:04:26.735 --> 00:04:30.353
The object that corresponds to the in operator is called

00:04:30.368 --> 00:04:36.176
Container LiarContainer is implemented to return the opposite result of

00:04:36.191 --> 00:04:41.324
the actual in operator Thus the class has methods that

00:04:41.338 --> 00:04:47.353
correspond to most operators and functions By implementing the appropriate

00:04:47.368 --> 00:04:52.265
methods both useless and useful objects can be easily implemented

00:04:53.279 --> 00:04:57.529
Next is the len function To make your own class

00:04:57.618 --> 00:05:02.735
correspond to the len function implement the len method The

00:05:02.750 --> 00:05:06.500
object that corresponds to the len function is also called

00:05:06.515 --> 00:05:13.397
Sized FibonacciSized returns the Fibonacci sequence when the len function

00:05:13.412 --> 00:05:15.912
is used to find the number of elements in an

00:05:15.926 --> 00:05:20.868
object Since the len method only needs to return an

00:05:20.882 --> 00:05:23.882
int value at the end it is no problem to

00:05:23.897 --> 00:05:27.426
return the value of the Fibonacci sequence instead of the

00:05:27.441 --> 00:05:32.338
number of elements in the data structure Yes no problem

00:05:33.353 --> 00:05:37.618
Next is the for statement There are several ways to

00:05:37.632 --> 00:05:40.897
realize the for statement but this time we will use

00:05:40.912 --> 00:05:45.838
the method that implements the iter method The iter method

00:05:45.912 --> 00:05:49.500
also only needs to return an iterator which in this

00:05:49.515 --> 00:05:52.779
case is shuffled but it can be an empty iterator

00:05:52.941 --> 00:05:57.368
for example or an iterator of a completely unrelated object

00:05:58.397 --> 00:06:01.941
An object corresponding to a for statement is called an

00:06:01.956 --> 00:06:07.235
iterable Even if an object returns only an empty iterator

00:06:07.529 --> 00:06:12.485
it is iterable So far we have introduced objects that

00:06:12.500 --> 00:06:18.294
correspond to in len and for statements To implement Python

00:06:18.309 --> 00:06:23.368
objects you need to understand Python's object protocols such as

00:06:23.382 --> 00:06:27.353
contains for in and len for len You can read

00:06:27.368 --> 00:06:32.882
the official Python documentation and yes Python Distilled to understand

00:06:32.897 --> 00:06:38.735
it Please buy it However it is difficult to implement

00:06:38.750 --> 00:06:43.956
a class from scratch that satisfies the object protocol This

00:06:43.971 --> 00:06:48.000
is where the abstract base class in collections . abc

00:06:48.015 --> 00:06:53.823
comes in handy Container Sized and Iterable are also names

00:06:53.882 --> 00:06:59.632
in ABC respectively Simply put you can easily implement the

00:06:59.647 --> 00:07:03.588
class you want by inheriting from ABC that satisfies the

00:07:03.603 --> 00:07:08.265
interface you want If you are wrong Python will tell

00:07:08.279 --> 00:07:13.926
you And the common interface of List Tuple Dictionary and

00:07:13.941 --> 00:07:20.191
Set is Collection The interface that satisfies Sized Container and

00:07:20.206 --> 00:07:25.588
Iterable is Collection Simply inherit from the previous class to

00:07:25.603 --> 00:07:30.588
complete the Collection If you do not want multiple inheritance

00:07:31.000 --> 00:07:36.074
you may implement methods individually This is the basic section

00:07:36.309 --> 00:07:38.750
and you can do some interesting things up to this

00:07:38.765 --> 00:07:42.529
point but you also want to create something similar to

00:07:42.544 --> 00:07:47.794
a list or tuple ABCs for existing data structures are

00:07:47.809 --> 00:07:51.382
also available so you can implement your own lists and

00:07:51.397 --> 00:07:56.529
tuples The first one is ModularSequence which is a data

00:07:56.544 --> 00:08:01.176
structure similar to a tuple I mentioned earlier that there

00:08:01.191 --> 00:08:04.941
are multiple ways to realize a for statement and one

00:08:04.956 --> 00:08:10.706
way other than iter is to implement getitem ModularSequence implements

00:08:10.721 --> 00:08:14.441
a sequence of numbers that goes on indefinitely by including

00:08:14.456 --> 00:08:19.529
a modular calculation In this way values that should not

00:08:19.544 --> 00:08:24.485
exist can also be retrieved It goes on infinitely so

00:08:24.500 --> 00:08:27.926
a count or for statement would result in an infinite

00:08:27.941 --> 00:08:34.015
loop I did it The dictionary also inherits from Mapping

00:08:34.029 --> 00:08:41.073
ABC and simply implements the necessary methods MisprintedDictionary messes up

00:08:41.147 --> 00:08:45.853
during initialization It may be messed up but it still

00:08:45.868 --> 00:08:51.559
functions as a dictionary This is a dictionary It is

00:08:51.573 --> 00:08:56.118
not ex-dictionary As you can see when you actually move

00:08:56.132 --> 00:08:59.882
it it is in pieces But this is also a

00:08:59.897 --> 00:09:05.265
dictionary The set should also be implemented to satisfy Set

00:09:05.279 --> 00:09:11.059
ABC Messing up the lt method makes inclusion relations weird

00:09:12.073 --> 00:09:15.000
As a set it is strange but as a data

00:09:15.015 --> 00:09:20.456
structure the dictionary is implemented correctly This was a bit

00:09:20.471 --> 00:09:25.294
rushed but I will summarize We have implemented a useless

00:09:25.309 --> 00:09:30.721
Python object The object itself is useless but the way

00:09:30.735 --> 00:09:35.765
it is created is useful Also by using collections .

00:09:35.779 --> 00:09:40.750
abc we can implement it more easily The key is

00:09:40.765 --> 00:09:45.573
the object protocol Once you understand it you are free

00:09:45.588 --> 00:09:50.103
to go from useful to useless Thanks for your attention

